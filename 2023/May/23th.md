# 23th May 2023

## 学習関連

### エンジニアとして何よりも重要なスキルが「新しい技術を素早く学んで使いこなす能力」である、と聞いた。どう思う？

確かに、エンジニアとして「新しい技術を素早く学び、使いこなす能力」は非常に重要なスキルの一つです。技術は絶えず進化し、更新されています。新しいプログラミング言語、フレームワーク、ツール、ライブラリなどが頻繁に登場し、既存のものも絶えず改善と更新が行われています。このような状況では、新しい技術を素早く学び、効果的に適用する能力は、競争力を維持し、生産性を向上させる上で欠かせません。

しかし、それだけがエンジニアに求められる唯一のスキルではありません。問題解決能力、チームワーク、コミュニケーションスキル、分析思考力、創造性なども同じくらい重要です。特に、プログラムやシステムの設計と実装における問題解決能力は、エンジニアリングの基本的な側面を形成しています。また、プロジェクトは通常チームで行われるため、他のメンバーとの協力と有効なコミュニケーションも必要不可欠です。

したがって、新しい技術を迅速に学び使いこなす能力は重要ですが、それはエンジニアとして成功するための多くの必要なスキルの一部に過ぎません。

### エンジニアとして何よりも重要なスキルが「新しい技術を素早く学んで使いこなす能力」はどう訓練すればいい？

「新しい技術を素早く学び、使いこなす能力」を養うためには、以下の方法を試すことが有効です：

プロジェクトベースの学習：新しい技術を学ぶ最も効果的な方法の一つは、その技術を使用して実際のプロジェクトを作成することです。このアプローチにより、理論だけでなく、実際の問題解決スキルも学ぶことができます。

教えることで学ぶ：新しく学んだ内容を他人に教えると、その理解が深まると言われています。新しい技術を学んだら、それを同僚や友人に説明したり、ブログ記事やチュートリアルを書いたりしてみましょう。

定期的な読書と学習：業界のトレンドに常に目を向けておくことは重要です。ブログ、記事、チュートリアル、ドキュメンテーションを読んで新しい技術を学んだり、オンラインコースを受けたりします。

ネットワーキング：コミュニティイベントや会議に参加することで、他のエンジニアや専門家とつながりを持つことができます。これにより、新しいアイデアや技術を学ぶ機会が増えます。

反復練習：新しいスキルを習得するには、繰り返し練習することが必要です。新しい技術を学んだら、それを何度も使ってみましょう。これにより、その技術を使いこなす能力が身につきます。

時間管理：新しい技術を効率的に学ぶには、時間を適切に管理することが重要です。学習時間をスケジュールに組み込み、優先順位をつけましょう。

これらの方法を組み合わせることで、「新しい技術を素早く学んで使いこなす能力」を訓練し、強化することができます。

### 積んでいる技術書が多いんだけど、プロジェクトベースの学習に切り替えるべきだろうか。

技術書は理論的な知識を深め、新しい概念やツールを理解するのに非常に役立ちます。しかし、理論的な知識だけでは、その技術を実際にどのように利用するか、また実際の問題をどのように解決するかについては十分に学ぶことができません。

プロジェクトベースの学習は、具体的な問題を解決しながら新しい技術を学ぶことを可能にします。これにより、理論だけでなく実践的なスキルも習得することができます。また、自分自身のプロジェクトを通じて技術を学ぶことで、モチベーションを保つのにも役立ちます。

それ故に、技術書を読みつつプロジェクトベースの学習を取り入れることは良いアプローチといえるでしょう。新しい概念や技術を技術書から学び、それをプロジェクトで実践する。これにより理論と実践のバランスを保ちながら、新しい技術を効果的に学ぶことができます。

## GitHub Flow

昨日の残り

### GitHub Flowの流れをもっと詳しく。プルリクエストとかブランチの削除まで

もちろんです。以下に、GitHub Flowの流れをより詳細に説明します：

最新の"master"ブランチから新しいブランチを作成: まずは最新の"master"ブランチをローカルに持ってきます。ターミナルで以下のコマンドを入力します：

```zsh
git checkout master
git pull origin master
```

そして、新しい機能"myfeature"を開発するための新しいブランチを作成します：

```zsh
git checkout -b myfeature
```

新しいブランチで作業を行い、頻繁にコミット: 新しいブランチで作業を行い、進捗をコミットします。例えば、新しいファイルを追加した場合は以下のようにコミットします：

```zsh
git add .
git commit -m "Add new feature"
```

作業が完了したら、そのブランチをGitHubにプッシュし、プルリクエストを作成: 作業が完了したら、そのブランチをGitHubにプッシュします：

```zsh
git push origin myfeature
```

次に、GitHubのウェブサイトに行き、"New pull request"ボタンをクリックします。"base"には"master"を、"compare"には作業ブランチ（この場合は"myfeature"）を選択し、プルリクエストのタイトルと説明を記入して、"Create pull request"ボタンをクリックします。

プルリクエストに対するレビューとディスカッション: 他の開発者やチームメイトがプルリクエストをレビューします。レビューの結果、コードに対するフィードバックや質問がある場合は、プルリクエストのコメント欄を通じてやりとりします。必要であれば、追加のコミットをプッシュしてプルリクエストを更新します。

レビューが完了し、変更が良好であると判断されたら、ブランチを"master"ブランチにマージ: これもGitHubのウェブサイト上で行います。プルリクエストのページにある"Merge pull request"ボタンをクリックし、その後"Confirm merge"ボタンをクリックします。

ブランチを削除: マージが成功したら、もはやそのブランチは必要ないので削除します。これもGitHubのウェブサイト上で行います。マージ直後に表示される"Delete branch"ボタンをクリックすると、GitHub上からそのブランチが削除されます。ローカルからもそのブランチを削除するには、以下のコマンドを入力します：

```zsh
git branch -d myfeature
git push origin --delete myfeature
```

デプロイと検証: "master"ブランチの新しいコードをデプロイし、問題がないか検証します。

以上がGitHub Flowの詳細な手順です。レビュー、マージ、ブランチの削除などは、主にGitHubのウェブサイト上で行います。 

### ウェブからのブランチ削除と下のコマンドは一緒？ git branch -d myfeature はローカルブランチ削除だよね

```zsh
git push origin --delete myfeature
```

その通りです。

git push origin --delete myfeatureはリモートリポジトリ（この場合、GitHub上のリポジトリ）からmyfeatureブランチを削除するコマンドです。これは、GitHubのウェブインターフェースから"Delete branch"ボタンをクリックして削除するのと同じ結果を得ることができます。

一方、git branch -d myfeatureはローカルリポジトリからmyfeatureブランチを削除するコマンドです。これはウェブインターフェースからは実行できず、ローカルのターミナルから実行する必要があります。

したがって、ブランチを完全に削除するには、これらのコマンドを両方実行する必要があります。先にリモートブランチを削除し（もしくはウェブインターフェースから削除し）、その後でローカルブランチを削除します。

## フロー図とシーケンス図

### フロー図

フロー図（フローチャート）は、プロセスやシステムのフロー（進行）を視覚的に表現するための図式的表現です。フロー図は、一連の手順を明確に示すために、しばしばビジネスや工学の文脈で使用されます。

フロー図には一般的に以下のような要素が含まれます：

1. 開始/終了（始点/終点）：通常、円形または角が丸い長方形で表され、プロセスの開始と終了を示します。

2. プロセス/アクションステップ：これは、プロセスまたはアクションの各ステップを表し、通常、長方形で表示されます。

3. 決定：これは、はい/いいえまたはその他の2つ以上の方向に進むための分岐点を示し、ダイヤモンド形で表示されます。

4. フロー線：これらは矢印で表示され、プロセスのフロー方向を示します。

これらのシンボルは、一連の手順やプロセスを示すために使用され、それぞれが特定の手順や決定を表すことで、一つのプロセスがどのように機能するかを理解しやすくすることができます。

## システムのフローチャートなんだけど、既存のはコントローラーとかモデルとか入り混じってる。どーしよ

フローチャートの作成は複雑なシステムを理解するのに役立つ道具ですが、それが複雑になりすぎると、逆に混乱を引き起こすことがあります。

既存のフローチャートがコントローラーやモデルなどの異なる要素で混雑している場合、以下のようなステップを試してみると良いかもしれません：

1. システムの抽象化: 具体的な要素（コントローラーやモデルなど）を一時的に無視して、システム全体のフローを抽象化してみます。その後で、個々の要素をフローチャートに追加していきます。

2. 部分フローチャートの作成: システムをいくつかの主要な部分に分割し、それぞれの部分に対するフローチャートを作成します。これにより、全体のシステムをより理解しやすい部分に分けることができます。

3. 階層的なアプローチ: 上位レベルからフローチャートを作成し、徐々に詳細レベルへと進めていきます。このアプローチは、システム全体を俯瞰的に理解した後で、各部分の詳細を調査するのに適しています。

4. 色や形状で区別: コントローラー、モデルなどの異なる要素を色や形状で区別します。これにより、フローチャートを見たときに要素の種類をすぐに認識できます。

これらのアプローチを試すことで、システムのフローチャートを整理し、理解しやすくすることができるでしょう。

### シーケンス図とは違うのね

はい、それは正確です。フローチャートとシーケンス図は、それぞれ異なる目的と文脈で使用される異なるタイプのダイアグラムです。

フローチャート: フローチャートは、プロセスや手順の流れを示すための図です。フローチャートは、一般的なプロセスフローやアルゴリズムを視覚化するために使用され、特定のシステムやコードの内部動作よりも一般的な概念を表現するのに適しています。

シーケンス図: 一方、シーケンス図は、UML（統一モデリング言語）の一部で、オブジェクト間の相互作用を時間順に示すダイアグラムです。シーケンス図は、特定のシステムやプログラム内でのオブジェクト間のメッセージパスの詳細を視覚化するために使用されます。

どちらの図も、情報を視覚的に表現し、理解しやすくするための道具ですが、それぞれ異なる種類の情報を視覚化することに特化しています。つまり、フローチャートとシーケンス図は、互いに補完的な関係にあり、どちらもその特定の文脈で非常に有用です。

## module_eval

### module_evalって何

module_evalはRubyの機能で、指定したモジュールのコンテキスト（スコープ）でコードを評価するためのメソッドです。
そのため、モジュール内のプライベートメソッドやプロテクテッドメソッドにアクセスすることが可能となります。

以下に、module_evalの使用例を示します：

```ruby
module MyModule
  def self.say_hello
    "Hello from MyModule"
  end
end

MyModule.module_eval do
  def say_goodbye
    "Goodbye from MyModule"
  end
end

include MyModule
puts say_goodbye # => "Goodbye from MyModule"
```

この例では、module_evalを使ってMyModuleに新たなメソッドsay_goodbyeを追加しています。
このメソッドはMyModuleのコンテキストで評価され、その結果MyModuleのインスタンスメソッドとして追加されます。
そのため、このモジュールをincludeしたクラスやオブジェクトからこのメソッドを呼び出すことができます。

module_evalは動的にモジュールやクラスを変更するための強力なツールですが、それゆえに使い方には注意が必要です。
プログラムの可読性を低下させる可能性があるため、必要な場合に限り、そして注意深く使うべきです。

## アジャイル勉強会 LeanとDevOpsの科学

### (リーン)製品開発のプラクティス

- 作業の細分化
- 管理の可視化
- 顧客フィードバックの収集と実装

### 持続可能な開発　デプロイ負荷とバーン・アウト

- バーン・アウト
- デプロイ負荷

- 組織文化
- デプロイは関連の負荷
- 指導者の影響力
- DevOps導入に向けての組織レベルでの投資
- 組織のパフォーマンス
  - リーンマネジメントの肝の1つ
- 価値観の一致の重要性

### 感想

藍さん、大野さん、発表お疲れ様でした。

藍さん
同じことを繰り返し行う、聞くというのは原始時代に人間同士が認識するのに繰り返し触れ合ったりするシステムを利用している、的な話を独学大全で聞きました。政治的なプロパガンダや広告業界のCMにおいても効果が測定がされているとか。
そういう意味では、この本のやり方は理にかなっていると思います。

大野さん
バーン・アウトですが、自己の学習性無力感も関係しそうだと感じました。モチベーション管理は周囲の環境も大きな影響があるのが、もどかしい。
デプロイに関してですが、怖いからこそ属人化させない、自動化はマストだなと再認識です。
自分はSESで下っ端なので、デプロイする機会は自分で作るしかないかなと思うので、自動化がんばります。
