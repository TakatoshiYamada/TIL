# 30th May 2023

- [30th May 2023](#30th-may-2023)
  - [正規表現](#正規表現)
    - [正規表現について教えて](#正規表現について教えて)
    - [なんかいい例ない？](#なんかいい例ない)
  - [ディレクトリ構成書き出し](#ディレクトリ構成書き出し)
    - [Linuxのディレクトリ構成の調査のため、ExcelかGoogleスプレッドシートにディレクトリ構成を書き起こすことになった。なにかいい方法ある？](#linuxのディレクトリ構成の調査のためexcelかgoogleスプレッドシートにディレクトリ構成を書き起こすことになったなにかいい方法ある)
    - [ディレクトリと何をしているかをExcelで書こうと思うんだけど、グチャグチャになりそう](#ディレクトリと何をしているかをexcelで書こうと思うんだけどグチャグチャになりそう)
    - [rubyで書ける？](#rubyで書ける)
  - [scp](#scp)
    - [sshログインしているサーバからローカルにデータを転送したい](#sshログインしているサーバからローカルにデータを転送したい)
  - [treeの代替コマンド](#treeの代替コマンド)
    - [今の環境treeが使えないんだけど、代替コマンドある？](#今の環境treeが使えないんだけど代替コマンドある)
    - [`find . -type d | sed -e "s/[^-][^\/]*\//|/g"s/|\([^ ]\)/|-\1/"` も代替らしい。違いは何](#find---type-d--sed--e-s-gs--1-も代替らしい違いは何)

## 正規表現

### 正規表現について教えて

正規表現（Regex）は文字列のパターンマッチングを行うための強力なツールです。例えば、電子メールアドレス、電話番号、URLなど特定のパターンを持つ文字列を検索したり、検証したりするのに使用されます。

正規表現の一部を説明します：

1. メタ文字： . ^ $ * + ? { } [ ] \ | ( )

    これらの文字は特殊な意味を持ちます。文字列内で直接検索する場合は、 \ を前に置いてエスケープする必要があります。

2. キャラクタクラス： [...]

    角括弧内の任意の文字に一致します。たとえば、 [abc] は "a"、"b"、または "c" に一致します。

3. 量指定子： * + ? {n} {n,} {n,m}

   \* は0回以上の繰り返し、 + は1回以上の繰り返し、 ? は0回または1回の出現、 {n} はn回の繰り返し、 {n,} は少なくともn回の繰り返し、 {n,m} はnからm回の繰り返しを表します。

これらは正規表現の一部にすぎません。これは非常に深く、複雑なパターンマッチングを行うための強力なツールです。

### なんかいい例ない？

もちろんです。正規表現のいくつかの基本的な例を以下に示します：

1. 電子メールアドレスの確認：

    正規表現: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$

    これは、一般的な電子メールアドレスのパターンにマッチします。ユーザ名@ドメイン名.トップレベルドメインという形式をとります。

2. 電話番号の確認：

    正規表現: ^\d{10}$

    これは、10桁の電話番号（ハイフンなし）にマッチします。

3. 特定の単語が含まれるかの確認：

    正規表現: apple

    これは、任意の文字列に "apple" が含まれているかどうかを確認します。

4. すべて小文字のアルファベットの確認：

    正規表現: ^[a-z]+$

    これは、一つ以上の小文字のアルファベットからなる文字列にマッチします。

以上の例は非常に基本的なものですが、正規表現はこれらの基本的なパターンを組み合わせて非常に複雑な検索やマッチングを行うことができます。それぞれの言語や環境によって正規表現の実装には差異がありますので、詳しくは各言語のドキュメンテーションを参照してください。

## ディレクトリ構成書き出し

### Linuxのディレクトリ構成の調査のため、ExcelかGoogleスプレッドシートにディレクトリ構成を書き起こすことになった。なにかいい方法ある？

Linuxのディレクトリ構成を調査し、その結果をExcelやGoogleスプレッドシートに書き起こす方法としては、treeコマンドを使用するのが一番簡単かつ効率的です。treeコマンドは、指定したディレクトリ以下の構成をツリー形式で表示します。

次に、その方法について具体的に説明します。

まず、treeコマンドがインストールされていない場合はインストールしてください。以下のコマンドを実行します：

Ubuntu/Debian系：

```bash
sudo apt-get install tree
```

Red Hat/CentOS系：

```bash
sudo yum install tree
```

次に、ディレクトリ構造を取得します。これを行うためには、treeコマンドに対象となるディレクトリを指定します：

```bash
tree /path/to/directory
```

結果をテキストファイルに出力するためには、以下のようにリダイレクトを使用します：

```bash
tree /path/to/directory > output.txt
```

この出力ファイルを開いて、その内容をExcelやGoogleスプレッドシートにコピー&ペーストすればディレクトリ構成を視覚化することができます。

ただし、treeコマンドの出力はインデントと特殊文字（├── など）を使用しているため、ExcelやGoogleスプレッドシートにそのまま貼り付けると見栄えが悪くなるかもしれません。その場合は、テキストエディタを使用してフォーマットを調整するか、またはスクリプトを使用して必要な形式に変換すると良いでしょう。

### ディレクトリと何をしているかをExcelで書こうと思うんだけど、グチャグチャになりそう

それなら、treeコマンドでディレクトリ構造を出力した後、それをスクリプトで整形するのが良いと思います。その後、ExcelやGoogleスプレッドシートに貼り付けると、それぞれのディレクトリについてコメントを追加するスペースを作ることができます。

具体的には、以下のような形式にすると便利かもしれません：

```bash
/path/to/directory1, <ここにコメント>
/path/to/directory1/subdirectory1, <ここにコメント>
/path/to/directory1/subdirectory2, <ここにコメント>
/path/to/directory2, <ここにコメント>
/path/to/directory2/subdirectory1, <ここにコメント>
```

これを行うためには、treeコマンドの出力を加工するための簡単なスクリプトを書くことが必要になります。このスクリプトは、各行からインデントと特殊文字を削除し、各ディレクトリのパスをコンマで終わる形式にします。この形式なら、ExcelやGoogleスプレッドシートで読み込むときに各ディレクトリパスとコメントが異なるセルに自動的に分割されます。

次のPythonスクリプトは、上記のような整形を行います：

```python
import sys

for line in sys.stdin:
    line = line.rstrip()  # 改行を削除
    line = line.replace('|-- ', '')  # 特殊文字を削除
    line = line.replace('`-- ', '')  # 特殊文字を削除
    line = line.replace('   ', '')  # インデントを削除
    line = line.replace(' ', '_')  # スペースをアンダースコアに変換
    print(f'{line},')  # コンマを追加
```

このスクリプトをformat_tree.pyとして保存し、次のように使用します：

```bash
tree /path/to/directory | python3 format_tree.py > output.csv
```

この結果をExcelやGoogleスプレッドシートに貼り付けると、それぞれのディレクトリパスが1つのセルに入り、その隣のセルにコメントを追加するスペースが作られます。この方法なら、ディレクトリ構造がグチャグチャになる心配はありません。

### rubyで書ける？

もちろんです。Rubyで同様の処理を行うスクリプトを以下に示します：

```ruby
ARGF.each_line do |line|
  line = line.gsub(/\|-- /, '')   # 特殊文字を削除
  line = line.gsub(/\`-- /, '')   # 特殊文字を削除
  line = line.gsub(/^   /, '')    # インデントを削除
  line = line.gsub(/ /, '_')      # スペースをアンダースコアに変換
  puts "#{line.strip},"
end
```

これを format_tree.rb という名前のファイルに保存し、以下のように使用します：

```bash
tree /path/to/directory | ruby format_tree.rb > output.csv
```

このRubyスクリプトは、標準入力から読み取った各行に対して特殊文字を削除し、インデントを削除し、スペースをアンダースコアに変換し、そしてカンマを追加します。そして、その結果を標準出力に出力します。その結果をリダイレクトして output.csv というファイルに保存します。

なお、このスクリプトも上記のBashスクリプトと同様に、非常にシンプルなもので、大きなディレクトリ構造やスペースを含むファイル名/ディレクトリ名には完全に対応していません。これらのケースを適切に処理するには、より高度なスクリプトやツールが必要です。

## scp

### sshログインしているサーバからローカルにデータを転送したい

SSHでログインしているリモートサーバからローカルマシンへデータを転送するには、Secure Copy (SCP) コマンドを使うことが一般的です。
以下に基本的な使用方法を示します。

まず、SSH接続を終了してローカルマシンのコマンドラインに戻ります。exitコマンドを使うか、Ctrl + Dを押すことでSSH接続を終了できます。

次に、以下のコマンドを実行します。このコマンドはリモートマシン上のファイルをローカルマシンへコピーします。

```bash
scp username@remotehost:/path/to/remote/file /path/to/local/directory
```

ここで、

- username@remotehost はリモートマシンのユーザー名とホスト名（またはIPアドレス）

- /path/to/remote/file はリモートマシンのファイルのパス

- /path/to/local/directory はローカルマシンのディレクトリのパス

となります。

このコマンドを実行すると、リモートマシンのファイルがローカルマシンの指定したディレクトリへ転送されます。

なお、この方法は単一ファイルの転送を行います。ディレクトリ全体を転送する場合には、scpコマンドに-rオプション（再帰的にファイルをコピーする）を追加します。

```bash
scp -r username@remotehost:/path/to/remote/directory /path/to/local/directory
```

## treeの代替コマンド

### 今の環境treeが使えないんだけど、代替コマンドある？

tree コマンドの代替として、ls, find, duなどの組み合わせを利用することができます。これらのコマンドはほとんどのUnixベースのシステムにデフォルトでインストールされているはずです。

たとえば、find コマンドを使ってディレクトリツリーを表示するには以下のようにします：

```bash
find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'
```

これは現在のディレクトリから(.)全てのファイルとディレクトリを検索(find . -print)し、sed コマンドを使って適切なインデントとツリー構造を生成します。

また、ls コマンドと grep コマンドを使っても似たような結果を得ることができます。ただし、これはサブディレクトリを再帰的にリストアップしないため、同じ情報量を得るためには手間がかかります。

それぞれのコマンドがどのように動作するか、または特定の要件に合わせてどのように変更できるかを理解するには、各コマンドの man ページ(man find, man sed, man lsなど)を参照すると良いでしょう。

### `find . -type d | sed -e "s/[^-][^\/]*\//|/g"s/|\([^ ]\)/|-\1/"` も代替らしい。違いは何

この find コマンドと sed コマンドの組み合わせは、ディレクトリツリーの表示方法が前の例と少し異なります。具体的には：

```bash
find . -type d | sed -e "s/[^-][^\/]*\//| /g" -e "s/| \([^ ]\)/|- \1/"
```

このコマンドは次のように動作します：

- `find . -type d` は、現在のディレクトリ(.)からすべてのディレクトリ(-type d)を検索します。

- `sed -e "s/[^-][^\/]*\//| /g"` は、パスの各部分を | に置き換えます。つまり、パスの各セクションは垂直バーとスペースに置き換えられます。この時点で、各ディレクトリ名が | によって前方にインデントされます。

- `sed -e "s/| \([^ ]\)/|- \1/"` は、パスの最後の部分（実際のディレクトリ名）にハイフンとスペースを追加します。これにより、ツリー表示が更に明確になります。

このコマンドは、ディレクトリだけを対象としているのが特徴です。前の例ではファイルも含めて全てを対象にしていました。また、ツリーの表示形式も若干異なります。どちらのコマンドを使うべきかは、あなたがどの情報を必要とし、どのように表示されるべきかによるでしょう。
