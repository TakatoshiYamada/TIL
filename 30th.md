# 30th June 2023 

## SQL

### 開発用DBから詳細テーブルの情報を取り出したい。どういうSQLを書けばいい？

詳細テーブルの全ての情報を取得したい場合、以下のようなSQLクエリを使用できます：
sql
SELECT * FROM 詳細テーブル;
ただし、特定の情報だけを取得したい場合は、カラム名を指定する必要があります。例えば、name と age のカラムだけを取得したい場合は、以下のようにします：
sql
SELECT name, age FROM 詳細テーブル;
さらに、特定の条件を満たす行だけを取得したい場合は、WHERE 句を使用します。例えば、age が20より大きいレコードだけを取得する場合は、以下のようにします：
sql
SELECT * FROM 詳細テーブル WHERE age > 20;
これらは基本的なSQLクエリの例で、あなたが何をしたいかによってクエリは変わります。より具体的なニーズがあれば教えてください。
no database selectedって出る
"no database selected"というエラーは、SQLクエリを実行する前に特定のデータベースを選択していないことを示しています。そのため、まずデータベースを選択する必要があります。
MySQLを使用している場合、以下のSQLコマンドでデータベースを選択できます：
sql
USE データベース名;
このコマンドは、データベース名という名前のデータベースを選択します。このコマンドの後に、テーブルからデータを取得するSQLクエリを実行することができます。
nameがtestのデータを取得したい
nameがtestであるデータを取得するためには、以下のようなSQLクエリを使用します：
sql
USE データベース名; -- まずは適切なデータベースを選択
SELECT * FROM 詳細テーブル WHERE name = 'test'; -- 次にクエリを実行
このクエリは、詳細テーブルからnameカラムの値がtestであるすべてのレコードを取得します。カラム名やテーブル名、データベース名はあなたの環境に合わせて適宜書き換えてください。
rubyにてopen3.rb execでエラーが出た。Errno::ENOENTとも出てる
Errno::ENOENTエラーは、通常、Rubyが指定されたファイルやディレクトリを見つけられないときに発生します。open3.rb execを使用しているとのことなので、恐らくはexecに渡しているコマンドやファイルが存在しない、または正しく指定されていない可能性が高いです。
以下は一般的な対処法です：
execに渡しているコマンドやパスが正しいか確認してください。コマンドがシステムパス上に存在するか、もしくは絶対パスを使用しているか確認してみてください。
ファイルのパーミッションが適切に設定されているか確認してください。Rubyがファイルを読み込んだり実行したりするためには、適切な読み取りおよび実行パーミッションが必要です。
エラーメッセージ全体を確認して、どのファイルやディレクトリが見つからないのかを確認してください。エラーメッセージは通常、問題のあるファイルやディレクトリの名前を含んでいます。
具体的なコードや実行しているコマンドを教えていただけると、より具体的な助言が可能となります。
/usr/local/jdk1.5.0_07/bin/java -jar 「multiaribjpegconverter.jarのディレクトリ」だからjarがないのかな
Errno::ENOENTエラーが出ているのであれば、それは指定されたファイルまたはディレクトリが見つからないことを示しています。
この場合、以下の確認をしてみてください：
multiaribjpegconverter.jarファイルが実際に存在していること。その際にファイル名のスペルミスも確認してみてください。
multiaribjpegconverter.jarのディレクトリパスが正しいこと。絶対パスを使用している場合、そのパスが正確であることを確認してください。
javaコマンドのパスが正しいこと。/usr/local/jdk1.5.0_07/bin/javaが存在し、実行可能であることを確認してください。
上記の全てを確認した上で、それでも同じエラーが出る場合は、Rubyからシェルコマンドを実行する際のコード（おそらくOpen3を使っている部分）を見直してみてください。
以下のようなコードでシェルコマンドを実行することが可能です：
ruby
require 'open3'
Open3.popen3('/usr/local/jdk1.5.0_07/bin/java -jar /path/to/multiaribjpegconverter.jar') do |stdin, stdout, stderr, wait_thr|
  # ここで標準出力やエラー出力を取得・処理できます
end
上記の/path/to/multiaribjpegconverter.jar部分は、あなたのmultiaribjpegconverter.jarファイルが存在する正確なパスに置き換えてください。
jdkのバージョンってどこを調べればいいの
JDKのバージョンを確認するには、コマンドラインから以下のコマンドを実行します：
bash
java -version
このコマンドは、インストールされているJavaのバージョン情報を表示します。JDK（Java Development Kit）がインストールされている場合、そのバージョンも含まれます。
また、特定のJDKのバージョンを調べたい場合には、そのJDKのbinディレクトリ内のjavaコマンドに対して上記のコマンドを実行します。例えば：
bash
/usr/local/jdk1.5.0_07/bin/java -version
このコマンドは、/usr/local/jdk1.5.0_07にインストールされたJDKのバージョン情報を表示します。これらのコマンドは、一般的なUnixベースのシステム（Linux、macOSなど）で使用できます。WindowsではコマンドプロンプトまたはPowerShellから同様のコマンドを実行できます。
jdk1.5.0_07をインストールしないといけないことがわかった。
JDK 1.5.0_07の公式リリースはもう古く、現在はOracleの公式ウェブサイトから直接ダウンロードすることはできません。一部のサードパーティサイトは、これらの古いバージョンのJDKをホストしていることがありますが、それらのサイトからソフトウェアをダウンロードする際は注意が必要です。
また、あなたが管理者の権限を持っている企業や学校などの組織であれば、古いバージョンのJDKを保持しているかもしれません。必要なバージョンがあるかどうか確認してみてください。
もし可能であれば、新しいバージョンのJavaを使用することを検討してみてください。新しいバージョンは、セキュリティ修正、パフォーマンスの改善、新機能などが提供されています。
なお、OracleはJava SE 8以降のバージョンで新しいライセンスモデルを採用しており、商用利用する際にはライセンス購入が必要となります。無償でJavaを商用利用するには、OpenJDKというオープンソース版のJavaを使用することを検討してみてください。
以上の情報を参考に、適切な解決策を選択してください。なお、この情報は2021年9月までの情報に基づいています。現在はその後の変更があった可能性もありますので、最新の情報をご確認ください。
開発サーバにバイナリではないけど、同じバージョンがディレクトリとして存在しているのを確認した。そのままscpで持ってくるだけで使える？
実際にその方法が機能するかどうかは、いくつかの要素に依存します。一部のシステムでは、JDKを単純にコピーして別のマシンで使うことが可能ですが、依存関係や特定のシステム設定が必要な場合もあります。
具体的には以下の点を確認してみてください：
バイナリ互換性：古いマシンと新しいマシンの両方が同じアーキテクチャ（例：x86, x64, ARMなど）を使用していること。
依存関係：特定のシステムライブラリやツールに依存している場合、それらが新しいマシン上に存在し、適切なバージョンであること。
環境変数：JAVA_HOMEやPATHなどの環境変数が適切に設定されていること。
これらを確認した上で、scpやrsyncなどのツールを使用してJDKのディレクトリを新しいマシンにコピーします。そして、コピーが完了したら、新しいマシンでjava -versionコマンドを実行してJDKが正しく動作するか確認してみてください。
Linuxのどこかにjdkのtarがないか検索したい。
Linuxシステム上で特定のファイルを検索するには、findコマンドを使うのが一般的です。以下のコマンドは、システム全体を検索し、名前がjdkを含むtarファイルを見つけるためのものです：
bash
sudo find / -name "*jdk*.tar*"
上記のコマンドを解説すると、findはファイルを検索するコマンド、/は検索を開始するディレクトリ（この場合はルートディレクトリから全てのディレクトリを検索します）、-nameは検索するファイルの名前を指定するオプション、"*jdk*.tar*"はjdkとtarを名前に含むファイルを検索します。なお、*は任意の文字列にマッチします。
このコマンドを実行するには通常、ルート権限（sudo）が必要です。これは、システムの全てのディレクトリを検索するためです。ただし、システムの一部のディレクトリに対するアクセス権限が制限されている場合は、そのディレクトリにはアクセスできません。
Javaがパス通ってるか確認したい
Javaがパスに設定されているかを確認するには、以下のコマンドを実行します：
bash
which java
このコマンドは、javaという名前のコマンドがシステムのPATHにある場合にそのパスを表示します。javaがPATHに設定されていない場合、何も表示されません。
さらに、Javaのバージョンを確認したい場合は、以下のコマンドを実行します：
bash
java -version
これにより、Javaのバージョン情報が表示されます。これらのコマンドは、Linux、macOS、およびWindowsのコマンドプロンプトやPowerShellで動作します。
二つのサーバの環境をwhichで調べたら/usr/lib/jvm以下と/usr/local/binでJavaの位置が別れていた
whichコマンドが返すパスは、シェルが実行可能ファイルを探す順序（PATH環境変数によって決まる）に基づいています。つまり、あるサーバでは/usr/lib/jvm下のJavaが先に見つかり、もう一方のサーバでは/usr/local/bin下のJavaが先に見つかっているということです。
Javaのインストール方法やバージョンにより、その配置される場所は変わります。また、システムによっては、複数バージョンのJavaが異なる場所にインストールされていることもあります。
/usr/lib/jvmは一般的にはJavaのバージョン毎にディレクトリが作成され、その中にJDKやJREが配置されます。それに対して/usr/local/binは、一般的にユーザーが自分でインストールした（またはシステムが自動的にインストールした）ソフトウェアの実行ファイルが配置される場所です。このディレクトリにあるjavaコマンドは、おそらくあるバージョンのJavaへのシンボリックリンク（別の場所にある実行ファイルへの参照）でしょう。
必要なJavaバージョンに対するパスを正しく設定するには、JAVA_HOME環境変数を適切に設定し、その値をPATH環境変数に追加することが一般的です。これにより、特定のJavaバージョンをデフォルトとして使うようにシステムに指示することができます。
jvmディレクトリに違うバージョンのjdkが二つあってもいいの、
はい、それは全く問題ありません。同じシステム上に複数のJavaバージョン（JDK）をインストールすることは一般的なことです。これは、異なるアプリケーションが異なるJavaバージョンを要求するためによく行われます。
実際には、/usr/lib/jvmディレクトリ以下には通常、複数のJavaバージョン（JDKとJREの両方）がインストールされています。各バージョンは自身のサブディレクトリに格納されています。
ただし、同時に実行できるJavaバージョンは1つだけです。そのため、あるJavaバージョンをデフォルトとして設定するためには、JAVA_HOME環境変数とPATH環境変数を適切に設定する必要があります。これにより、システムは指定されたバージョンのJavaを使用するようになります。
/usr/localからlibにシンボリックリンクをつけたい
指定したディレクトリから/usr/local/libへのシンボリックリンクを作成するには、lnコマンドの-sオプションを使います。以下のようにコマンドを実行します：
bash
sudo ln -s /path/to/your/directory /usr/local/lib/your_link_name
ここで、/path/to/your/directoryはシンボリックリンクの元となるディレクトリのパスを、your_link_nameは作成するシンボリックリンクの名前を指定します。このコマンドを実行するには通常、管理者（root）の権限が必要となります。
ただし、シンボリックリンクを作成する前に、既に同じ名前のファイルやディレクトリが/usr/local/libに存在しないか確認してください。もし存在する場合、そのファイルやディレクトリはシンボリックリンクによって上書きされます。
シンボリックリンクが正しく作成されたかを確認するには、ls -l /usr/local/libコマンドを実行します。これにより、/usr/local/libディレクトリ内のファイルとディレクトリの一覧が表示され、その中に作成したシンボリックリンクが表示されます。
error while loading shared libraries libjli.so cannot open shared object file no suchってエラーが出た
libjli.soが見つからない、または読み込めないというエラーメッセージは、Javaランタイムが必要とするライブラリがシステム上で見つからないことを示しています。
この問題の解決方法の一つは、libjli.soが存在するディレクトリへのパスをLD_LIBRARY_PATH環境変数に追加することです。libjli.soは通常、JDKのインストールディレクトリ内のlibサブディレクトリに存在します。以下のコマンドでLD_LIBRARY_PATH環境変数にこのパスを追加します：
bash
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/your/jdk/lib
ここで、/path/to/your/jdk/libはlibjli.soが存在するディレクトリのパスを指定します。
ただし、この修正は一時的なもので、新たにシェルを開始するとこの設定は失われます。この設定を永続化するには、このコマンドを~/.bashrc、~/.bash_profile、~/.profileなどの適切なシェルの設定ファイルに追加します。
なお、この情報は一般的なガイダンスであり、具体的な解決策はシステムの具体的な状況によります。
そもそもなぜにrailsの中にjdkとかjarがあるんだか
Ruby on Rails（Rails）アプリケーションにJava Development Kit（JDK）やJavaのJARファイルが含まれている理由は、そのアプリケーションがJavaコードやJavaライブラリを何らかの形で利用しているからだと思われます。
以下にそのような状況のいくつかを示します：
Javaライブラリの利用：ある特定の機能について、Javaで提供されているライブラリがRubyで利用可能なものより優れているか、より広範囲の機能を提供している場合、RailsアプリケーションはそのJavaライブラリを直接呼び出すことがあります。
Javaベースのサービスとの連携：RailsアプリケーションがJavaベースのサービス（例：Apache Kafka, Apache Solrなど）と連携している場合、それらのサービスとのインタラクションを助けるためにJavaコードを使用することがあります。
JRubyの利用：JRubyは、Javaプラットフォーム上で動作するRubyの実装です。JRubyを利用すると、JavaとRubyの両方のライブラリを利用できます。この場合、RailsアプリケーションはJDKを必要とします。
レガシーシステムとの連携：特定の既存（レガシー）システムがJavaで書かれている場合、そのシステムと連携するためにJavaコードを利用することがあります。
これらのいずれか、またはそれらの組み合わせが、RailsアプリケーションにJDKやJARファイルが含まれる理由となっている可能性があります。具体的な理由を知るためには、アプリケーションのコードやドキュメンテーションを調査する必要があります。
アプリケーション設計としてあんま褒められたことじゃないと思うんだけど
あなたの考えは確かに一理あります。一般的には、一つのアプリケーションやシステム内で複数のプログラミング言語を混在させることは、管理や運用、保守の観点から見るとコストが高くなりがちです。特に、異なるプログラミング言語間で共有する必要があるデータや状態がある場合、その調整が困難となり、複雑さを増すことがあります。
また、JavaとRubyのように、プログラミング言語やランタイム環境が大きく異なる場合、それぞれの特性や制約を理解していなければならず、開発者がそれらを習得するための学習コストも増大します。さらに、それぞれのランタイム環境に対するパッチ適用やバージョンアップを追跡し、対応する運用の負荷も増えます。
しかしながら、全ての設計決定は一定のトレードオフを伴います。上記で述べたようなシナリオ（Javaライブラリの利用、Javaベースのサービスとの連携、JRubyの利用、レガシーシステムとの連携）では、RubyとJavaの混在が必要となる場合があります。このような設計が選ばれた背景には、特定の技術的な要件や制約、既存のコードベースへの依存、開発チームのスキルセット、時間やリソースの制約など、様々な理由が考えられます。
したがって、その設計が良いか悪いかを判断するには、具体的なコンテキストや要件を理解する必要があります。その上で、可能であれば一貫性のある技術スタックを保つこと、または言語間のインタフェースを明確に定義し管理することが重要です。
don't convert arib-jpg for banner id=3 , banner subtier id=とかいう謎のエラーが起きてる
あなたが遭遇しているエラーメッセージは、特定の「banner id=3」および「banner subtier id」に関連する "arib-jpg" の変換が何らかの理由で行われなかったことを示しています。
"arib-jpg" はおそらく、特定の画像フォーマット（ARIB - Association of Radio Industries and Businesses のJPEG形式）を指しています。そして、"banner id=3" および "banner subtier id" は、変換しようとした特定のデータまたはリソースを指している可能性があります。
ただし、これらの情報だけでは具体的なエラー原因を特定するのは難しいです。エラーメッセージが発生したコードのコンテキスト（どの操作を行っていたか、どのような環境下で起きたかなど）や、エラーメッセージの前後に出力されたログ情報などを確認すると、問題の原因を特定する手がかりが得られるかもしれません。
また、アプリケーションのソースコードやドキュメンテーションを調査して、このエラーメッセージが何を意味し、どのような状況で発生するのかを理解すると良いでしょう。可能であれば、アプリケーションの開発者や保守者に問い合わせるのも一つの手段です。
そもそもlibjli.soがLinuxに存在するのかわからない。検索したい
libjli.soは通常、Java Development Kit(JDK)の一部としてインストールされ、JDKのディレクトリ内に存在します。そのため、システム全体でlibjli.soを探すには、findコマンドを使うと便利です。
以下のコマンドを実行してみてください：
bash
sudo find / -name libjli.so
このコマンドは、システム全体(/)を検索し、libjli.soという名前のファイルを探します。ただし、大量のディレクトリとファイルを検索するため、結果が表示されるまでには時間がかかることがあります。
また、sudoを使う理由は、一部のディレクトリにはrootユーザーのみがアクセスでき、一般ユーザーでは検索できないからです。したがって、全ての可能な場所を検索するにはsudoを使ってコマンドを実行する必要があります。
やっぱパスが通ってないのかな
パスが通っていない場合、システムはコマンドを実行するための実行可能ファイルや、必要なライブラリを見つけることができません。前述の libjli.so について言えば、このファイルは Java の一部であり、Java コマンドを実行するために必要となります。このライブラリがパスに含まれていない場合、Java コマンドの実行に失敗します。
Java の場合、実行可能ファイルのパスを通すためには、PATH 環境変数に Java の bin ディレクトリへのパスを追加します。また、Java が必要とするライブラリを見つけるためには、LD_LIBRARY_PATH 環境変数に Java の lib ディレクトリへのパスを追加します。
具体的な手順は次の通りです：
まず、Java のインストール場所を確認します。これは一般的に /usr/lib/jvm/java-{version} や /usr/java/{version} などの場所になります。
次に、以下のコマンドを実行して PATH と LD_LIBRARY_PATH 環境変数に必要なパスを追加します：
bash
export PATH=$PATH:/path/to/java/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/java/lib
上記のコマンドでは、/path/to/java/bin と /path/to/java/lib をそれぞれ実際のパスに置き換えてください。
これらの変更は現在のシェルセッションにのみ適用されます。新しいシェルセッションを開始すると、これらの設定は消えてしまいます。これらの設定を永続化するためには、上記の export コマンドをあなたのシェルの設定ファイル（例えば、bash の場合は ~/.bashrc や ~/.bash_profile）に追加します。
上のパスをbashrcに書く時に二行目は$PATHからじゃなくていいの？
おっしゃる通りで、LD_LIBRARY_PATHを設定する際には、前のPATH環境変数は必要ありません。したがって、以下のように設定できます：
bash
export PATH=$PATH:/path/to/java/bin
export LD_LIBRARY_PATH=/path/to/java/lib
ここで、/path/to/java/binと/path/to/java/libは、具体的なJavaのbinディレクトリとlibディレクトリへのパスに置き換えてください。
ただし、すでにLD_LIBRARY_PATHに他のライブラリのパスが設定されている場合は、それらを上書きしないように注意してください。その場合は、新たにJavaのlibディレクトリのパスを追加するようにします：
bash
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/java/lib
これは、既存のLD_LIBRARY_PATHの値に新しいパスを追加するだけで、既存の設定を上書きすることはありません。
やっぱlibjli'so can't open shared object no suchって出るわ
エラーメッセージ "libjli.so: cannot open shared object file: No such file or directory" は、一般的には、システムが libjli.so という名前の共有ライブラリを見つけることができない場合に表示されます。これは、環境変数 LD_LIBRARY_PATH が正しく設定されていない、あるいは設定されているパスに libjli.so が存在しない場合に起こります。
この問題を解決するためには、次の手順を試してみてください：
libjli.so が本当に存在するかどうか確認します。次のコマンドを実行して、libjli.so がシステム上のどこに存在しているかを見つけてください：
bash
sudo find / -name libjli.so
libjli.so が見つかったら、そのディレクトリパスをコピーしてください。
LD_LIBRARY_PATH 環境変数に libjli.so が存在するディレクトリのパスを追加します。例えば、libjli.so が /usr/lib/jvm/java-1.5.0-openjdk-amd64/jre/lib/amd64/jli/libjli.so に存在する場合、次のコマンドを実行します：
bash
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/jvm/java-1.5.0-openjdk-amd64/jre/lib/amd64/jli
もし、エラーがまだ解消しない場合は、システムが 32 ビットか 64 ビットかを確認し、libjli.so のパスが適切なアーキテクチャ（32 ビット用または 64 ビット用）に対応していることを確認してください。具体的には、libjli.so のあるディレクトリ内に i386 （32 ビット）または amd64（64 ビット）のディレクトリがあるかどうかを確認します。
上記の手順に従っても問題が解決しない場合は、より詳細な情報が必要となります。具体的には、エラーが発生する具体的なコマンドやシナリオ、およびシステムの詳細な情報が必要です。それにより、より具体的な解決策を提供することが可能となります。
bashrcを更新した。一度webappを立ち上げ直す必要はある？
~/.bashrc などの設定ファイルを更新した場合、その設定を反映させるためには新しいシェルセッションを開始するか、現在のシェルで source ~/.bashrc コマンドを実行する必要があります。
そのため、あなたのWebアプリケーションが新たに追加されたパス設定を反映させるためには、アプリケーションを再起動することが推奨されます。もしそのWebアプリケーションが新しいシェル環境で起動されるのであれば、更新された設定は自動的に反映されます。しかし、アプリケーションがすでに起動中のシェルセッションで動作している場合、新しい設定を反映させるためにはアプリケーションを再起動するか、設定を手動で読み込む必要があります。
もしWebアプリケーションがRuby on Railsで開発されているなら、rails server コマンドを使用してアプリケーションを停止し、再起動することで新しい設定を反映させることができます。
ローカルで問題のコードを叩いたらlibjava.soのエラーが出た
この問題も libjli.so と同様、libjava.so ファイルが見つからないという問題です。共有ライブラリ libjava.so が必要なアプリケーションを実行しようとしているが、システムがそのファイルを見つけられないという状況です。
解決策は libjli.so の場合と同様で、libjava.so の場所を見つけて、その場所を LD_LIBRARY_PATH 環境変数に追加します。以下に具体的な手順を示します：
libjava.so の場所を確認します。以下のコマンドを使うと、ファイルシステム全体を検索して libjava.so を見つけることができます：
bash
sudo find / -name libjava.so
libjava.so のパスが表示されたら、そのディレクトリパスを LD_LIBRARY_PATH 環境変数に追加します：
bash
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/libjava
ここで、/path/to/libjava は、find コマンドで見つけた libjava.so のパスに置き換えてください。
最後に、この設定を永続化するために、上記の export コマンドをシェルの設定ファイル（例えば bash の場合は ~/.bashrc）に追加します。
これらの手順に従っても問題が解決しない場合は、システムが32ビットか64ビットかを確認し、それに応じて適切な libjava.so を使用していることを確認してください。また、Javaのインストールが完全で、必要なすべてのライブラリが含まれていることを確認してください。
Javaのインストールが完全でない？でもjava -versionは出るのだけど
java -version コマンドが正常に動作する場合、Javaの基本的なインストールは正しく行われていると言えます。しかし、それは主にJavaのランタイム環境（JRE）が正しく機能していることを示しており、Javaの開発キット（JDK）に含まれる追加のツールやライブラリ、特に libjava.so のような特定の共有ライブラリが正しくインストールされていることを保証するものではありません。
あなたが特定のJavaアプリケーションを実行しようとしてエラーが発生する場合、それは通常、そのアプリケーションが必要とする特定のライブラリやツールがシステムに存在しない、あるいは見つけられないときに起こります。これは、例えば、アプリケーションがJDKの特定の部分を必要とするが、システムにはJREのみがインストールされているというケースで起こりえます。
この問題を解決するためには、まず libjava.so ファイルがシステム上に存在することを確認し、その場所を LD_LIBRARY_PATH 環境変数に追加します。また、この問題が解決しない場合、システムに完全なJDKがインストールされていることを確認し、適切なバージョンのJDKが使用されていることを確認してください。
fastcgiって何だっけ
FastCGIは、CGI (Common Gateway Interface) の高速な代替手段で、Webサーバとスクリプト間のデータの通信を可能にします。
CGI自体は非常に効果的なインターフェースでしたが、リクエストごとに新しいプロセスを開始するため、大量のリクエストを処理するとパフォーマンスが大きく低下するという問題がありました。
FastCGIは、この問題を解決するために設計されました。FastCGIは、リクエストを処理するために新しいプロセスを作成するのではなく、すでに実行中のプロセスを再利用します。これにより、FastCGIはCGIよりも優れたパフォーマンスを提供し、大量のリクエストをより効率的に処理することができます。
FastCGIは特に、動的なコンテンツを生成するためのスクリプト（例えば、PHPやRubyなど）を実行するために使用されます。Webサーバは、リクエストが来るたびに新しいプロセスを生成するのではなく、FastCGIプロセスマネージャを通じて実行中のプロセスにリクエストを送り、その結果をクライアントに返すことで、効率的にリクエストを処理します。
