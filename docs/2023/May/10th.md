# 10th May 2023

- [10th May 2023](#10th-may-2023)
  - [仕事 DB設計](#仕事-db設計)
    - [SQLのプライマリーってPKのほかにユニーク制約もつくの？](#sqlのプライマリーってpkのほかにユニーク制約もつくの)
    - [モデルにbelongs\_toだけ書くとテーブルはどうなるの？](#モデルにbelongs_toだけ書くとテーブルはどうなるの)
    - [テーブルにdefault 0ってある場合は設計書に必須って書かないとダメかな](#テーブルにdefault-0ってある場合は設計書に必須って書かないとダメかな)
    - [プライマリーキーidの時のインデックス名って何](#プライマリーキーidの時のインデックス名って何)
    - [明示的になってない場合においてMySQLのインデックス名はどうなる？](#明示的になってない場合においてmysqlのインデックス名はどうなる)
    - [Primary key(ID),  key a(a), constraint(b) forign key (b) preference c (c)だとどう？](#primary-keyid--key-aa-constraintb-forign-key-b-preference-c-cだとどう)
    - [上のもののkeyはユニーク制約つく？](#上のもののkeyはユニーク制約つく)
    - [テーブルの外部キーってどうやって設定するの？](#テーブルの外部キーってどうやって設定するの)
    - [マスタとトランザクションのテーブルって何？違いは？](#マスタとトランザクションのテーブルって何違いは)
  - [TIL](#til)
    - [TILって何](#tilって何)
    - [GitHubでTILリポジトリ作ってみようかな](#githubでtilリポジトリ作ってみようかな)
    - [今はDailyCodeというリポジトリで毎日コード書くようにしてるし、ReadingNotesって読書記録リポジトリも書いている。これらはTILに移した方がいいかな](#今はdailycodeというリポジトリで毎日コード書くようにしてるしreadingnotesって読書記録リポジトリも書いているこれらはtilに移した方がいいかな)
    - [複数のリポジトリを一つにまとめることって出来るの？](#複数のリポジトリを一つにまとめることって出来るの)
    - [難しそうだしTILはTILで切ったが無難そう](#難しそうだしtilはtilで切ったが無難そう)
  - [RFC3339形式](#rfc3339形式)
    - [RFC339形式って何](#rfc339形式って何)
  - [その他](#その他)
    - [真善美ってなに](#真善美ってなに)
    - [自分が何が得意かわからない。何があっても上位互換がいる。強みを活かせと言われても強みがないと思う](#自分が何が得意かわからない何があっても上位互換がいる強みを活かせと言われても強みがないと思う)

## 仕事 DB設計

### SQLのプライマリーってPKのほかにユニーク制約もつくの？

はい、その通りです。SQLでは、プライマリーキー（Primary Key, 略称PK）はそのテーブル内で一意（ユニーク）であることを保証します。つまり、プライマリーキーとして設定されたフィールドには、同じ値が二つ存在することはありません。

さらに、プライマリーキーはNULLを許可しません。これは、プライマリーキーがそのテーブルの各行（レコード）を一意に識別するためのものであるため、NULL（値が存在しない）が許可されないという制約もあります。

したがって、プライマリーキーは、一意性（ユニーク）制約とNULL不許可（NOT NULL）制約、この2つの制約を持つ特殊な種類のキーと言えます。

この特性により、データベースはプライマリーキーを通じて各レコードを迅速に検索し、関連するテーブル間でデータを正確にリンクすることが可能となります。

### モデルにbelongs_toだけ書くとテーブルはどうなるの？

belongs_toメソッドはRailsのモデルにおいて、他のモデルとの「1対多」の関連を示すために使われます。これは、「このモデルが他のモデルに所属している（belongs_to）」という関係を示します。

例えば、CommentモデルがPostモデルに所属しているとしたら、Commentモデルには次のように記述します。

```ruby

class Comment < ApplicationRecord
  belongs_to :post
end

```

この場合、commentsテーブルにはpost_idというカラムが必要となります。post_idカラムは、そのコメントがどのポストに所属しているのかを示す「外部キー」となります。そしてRailsはこのpost_idカラムを使用して、そのコメントがどのポストに所属しているかを把握します。

ただし、belongs_toメソッドをモデルに記述しただけでは、データベースのテーブル自体は何も変わりません。テーブルの構造を変更するには、マイグレーションを作成し、rails db:migrateコマンドを実行する必要があります。

### テーブルにdefault 0ってある場合は設計書に必須って書かないとダメかな

テーブルのカラムにdefault 0が設定されている場合、そのカラムに明示的に値が設定されなかったときにデフォルト値として0が自動的に設定されます。

そのため、このカラムが「必須」であるかどうかは、システムの要件やそのカラムがどのような目的で使われるかによります。

もし、そのカラムが本当に「必須」であり、ユーザーまたはシステムがそのカラムに明示的に値を設定する必要があるなら、設計書に「必須」と記述するべきです。ただし、その際には「デフォルト値が0である」という情報も付け加えると良いでしょう。

一方で、そのカラムが「必須」ではなく、ユーザーまたはシステムが値を設定しなくても良い場合（つまり、値が設定されなければデフォルトの0が使用される）なら、設計書に「必須」とは記述しない方が良いかもしれません。ただし、その際には「デフォルト値が0である」という情報を記述することが重要です。

つまり、データベースのカラムにデフォルト値が設定されているかどうかと、そのカラムが「必須」であるかどうかは、厳密には異なる概念であり、設計書にどのように記述するかはシステムの要件によるということです。

### プライマリーキーidの時のインデックス名って何

データベースシステムによりますが、プライマリーキーを設定すると、そのカラム（たとえば、id）に自動的にインデックスが作成されます。これはデータの検索性能を向上させるためのものです。

インデックス名は、データベースシステムや設定によりますが、一般的にはテーブル名とカラム名を組み合わせたような名前がつけられます。例えば、usersテーブルのプライマリーキーidに対するインデックス名は、users_pkeyやPRIMARYなどとなることがあります。

ただし、特定のデータベースシステムで具体的にどのような名前が付けられるかは、そのシステムのドキュメンテーションや設定を参照する必要があります。

また、SQL文で明示的にインデックスを作成するとき（CREATE INDEXを使用する場合など）は、自分で任意のインデックス名を指定することができます。\

### 明示的になってない場合においてMySQLのインデックス名はどうなる？

MySQLでは、プライマリーキーには自動的に名前が付けられ、その名前は通常 PRIMARY となります。つまり、明示的に名前を指定しない場合、プライマリーキーのインデックス名は PRIMARY となります。

これは以下のように確認することができます。以下は your_table_name というテーブルのインデックスを表示するコマンドです。

```sql
SHOW INDEX FROM your_table_name;
```

このコマンドを実行すると、テーブルのすべてのインデックスが表示されます。プライマリーキーのインデックス名は Key_name の列に表示され、その名前は PRIMARY となります。

注意点としては、プライマリーキーはテーブルに1つだけ存在することができ、それが PRIMARY という名前のインデックスに対応します。他の一般的なインデックス（非プライマリーキーのインデックス）は、明示的に名前を指定しない場合、MySQLが自動的に名前を生成します。この名前は通常、インデックスが適用されるカラム名に基づいています。

### Primary key(ID),  key a(a), constraint(b) forign key (b) preference c (c)だとどう？

指定したSQLスキーマに基づくと、以下のような理解が得られます。

Primary key(ID)：これはテーブルの主キーを設定しています。主キーはそのテーブルの各行を一意に識別するために使用されます。ここでは、ID列が主キーとして設定されています。主キーは自動的にユニークなインデックスが作成され、その名前は通常 PRIMARY となります。

key a(a)：これはa列に対する通常のインデックスを作成しています。このインデックスの名前はaです。インデックスはデータの検索速度を向上させるために使用されます。しかし、インデックスはデータベースの書き込み速度を若干遅くする可能性があるため、必要な場所にだけインデックスを作成することが推奨されます。

constraint(b) foreign key (b) references c (c)：これはb列を外部キーとして設定し、その外部キーが参照するテーブルと列を指定しています。ここでは、b列が外部キーとして設定され、cテーブルのc列を参照しています。外部キー制約は、参照整合性を保つために使用されます。つまり、b列の各エントリは、cテーブルのc列の値のいずれかと一致しなければなりません。

なお、具体的なSQLスキーマの設定やデータベースの動作は使用しているデータベース管理システム（DBMS）の種類やバージョンによりますので、具体的な操作を行う前に該当のDBMSのドキュメンテーションを確認してください。

### 上のもののkeyはユニーク制約つく？

key a(a) の部分で作成されるのは通常のインデックスで、これはデフォルトではユニーク制約を持ちません。つまり、同じ値を持つ行が複数存在しても問題ありません。

ユニーク制約を持つインデックスを作成したい場合は、UNIQUE KEY a(a) のように UNIQUE キーワードを使って定義します。これにより、a 列のすべての値が一意であることが強制され、同じ値を持つ行を追加しようとするとエラーが発生します。

なお、主キー (PRIMARY KEY) は自動的にユニーク制約を持つとともに、NOT NULL制約も持っています。これは、主キーがテーブルの各行を一意に識別するためのものであるためです。

### テーブルの外部キーってどうやって設定するの？

外部キーは、テーブルのカラムに対して設定される制約の一つです。外部キー制約は、そのカラムの値が他のテーブルのカラムの値と一致することを保証します。つまり、外部キー制約は参照整合性を保つために使用されます。

外部キー制約は、テーブルを作成するときにカラムに対して直接設定することもできますし、テーブルを作成した後にALTER TABLE文を使用してカラムに対して設定することもできます。

以下は、テーブルを作成するときに外部キー制約を設定する例です。

```sql
CREATE TABLE table_name (
  id INT PRIMARY KEY,
  other_id INT,
  FOREIGN KEY (other_id) REFERENCES other_table_name (id)
);
```

上記の例では、table_nameというテーブルを作成し、そのテーブルにはidという主キーとother_idという外部キーが設定されています。other_idはother_table_nameのid列を参照する外部キーとなっています。

以下は、テーブルを作成した後に外部キー制約を設定する例です。

```sql
ALTER TABLE table_name
ADD FOREIGN KEY (other_id) REFERENCES other_table_name (id);
```

上記の例では、table_nameというテーブルにother_idという外部キーを追加しています。other_idはother_table_nameのid列を参照する外部キーとなっています。

なお、具体的なSQLスキーマの設定やデータベースの動作は使用しているデータベース管理システム（DBMS）の種類やバージョンによりますので、具体的な操作を行う前に該当のDBMSのドキュメンテーションを確認してください。

### マスタとトランザクションのテーブルって何？違いは？

データベースにおける「マスタ」と「トランザクション」はテーブルのタイプを表しています。以下にそれぞれの特性を説明します。

マスタテーブル：マスタテーブルは、一般的に静的なデータを保存します。これは、システムの運用中に頻繁に変更されることのないデータです。例えば、顧客情報、製品情報、従業員情報などがマスタテーブルに保存されることがあります。これらの情報は、システム全体で共有され、参照されます。

トランザクションテーブル：トランザクションテーブルは、一時的なデータや変更頻度の高いデータを保存します。これは、システムの運用中に頻繁に生成され、更新されるデータです。例えば、販売記録、注文情報、在庫の移動などがトランザクションテーブルに保存されることがあります。

この2つのテーブルの主な違いは、データの性質とその使用方法です。マスタテーブルは参照データを提供し、トランザクションテーブルはビジネスプロセスを通じて生成されるデータを捕捉します。また、これらのテーブルはしばしばリレーションシップを持ち、トランザクションテーブルがマスタテーブルを参照する形でデータが連携されます。

## TIL

### TILって何

"TIL"は "Today I Learned" の略で、主にインターネット上で用いられる略語です。何か新しい知識や情報を得たときに、「今日私が学んだことは...」という意味で使われます。特にRedditなどの掲示板やソーシャルメディアでよく見かけます。これは、自分がその日に学んだ興味深い事実や新しい情報を共有するためのものです。

### GitHubでTILリポジトリ作ってみようかな

それは素晴らしいアイデアです！TILリポジトリをGitHubに作成することは、あなたが学んだことを整理し、他の人と共有するための素晴らしい方法です。以下に、TILリポジトリを作成する手順を示します。

GitHubにログインします。アカウントがない場合は、新たに作成します。

「New repository」をクリックします。

リポジトリの名前に「TIL」を入力します。

リポジトリの説明に、このリポジトリが何であるかを簡潔に説明します。例えば、「毎日学んだことを記録する」など。

リポジトリの可視性を「Public」に設定します。これにより、他の人があなたのTILを見ることができます。

「Initialize this repository with a README」をチェックします。これにより、リポジトリがREADMEファイルで初期化され、あなたが学んだことを詳細に書き留めることができます。

「Create repository」をクリックします。

これで、TILリポジトリが作成されました。これからは、あなたが学んだことをマークダウン形式で記録し、コミットとプッシュすることでリポジトリを更新できます。これは、学習の進行状況を可視化し、知識を整理するのに役立ちます。また、他の人があなたのTILを見ることで、彼ら自身が新しいことを学ぶきっかけにもなります。

### 今はDailyCodeというリポジトリで毎日コード書くようにしてるし、ReadingNotesって読書記録リポジトリも書いている。これらはTILに移した方がいいかな

それぞれのリポジトリが特定の目的に対して機能しているのであれば、そのまま維持することも一つの選択肢です。つまり、"DailyCode"はコーディング練習の進行を追跡し、"ReadingNotes"は読書の進捗と学んだことを記録するためのものです。

一方で、これらのすべての学習活動を一つの"TIL"リポジトリに統合することも考えられます。この方法の利点は、あなたの学習活動を一か所で追跡しやすくなること、そして他の人があなたの学びを一つの場所で見つけやすくなることです。

決定はあなたの個人的な好みと作業スタイルによります。あなたが情報をどのように整理し、公開したいと感じるかによるでしょう。どちらの選択肢も有効ですので、あなたにとって最も理にかなっていると感じる方を選んでください。

### 複数のリポジトリを一つにまとめることって出来るの？

GitHubで複数のリポジトリを一つにまとめることは可能ですが、それは主に新しいリポジトリを作成し、各リポジトリからのファイルをその新しいリポジトリに移動することを意味します。ただし、このプロセスはいくつかの手順を必要とし、各リポジトリのコミット履歴が新しいリポジトリに保持されない可能性があります。

もし各リポジトリのコミット履歴を新しいリポジトリに保持したい場合は、「サブモジュール」または「サブツリー」のような高度なGit機能を使用することができます。これらの機能は、一つのリポジトリ内に他のリポジトリを含めることを可能にします。ただし、これらの方法は複雑であり、Gitに精通していることが必要です。

新しいリポジトリにファイルを手動でコピーしてコミットすることで、複数のリポジトリを一つにまとめる簡単な方法もあります。この方法は簡単ですが、各ファイルのコミット履歴は保持されません。

以上のように、GitHubで複数のリポジトリを一つにまとめることは可能ですが、どの方法が適切かはあなたの具体的なニーズとGitの知識によるところが大きいです。

### 難しそうだしTILはTILで切ったが無難そう

その方が良いかもしれませんね。新しくTILリポジトリを作成することで、学んだことを記録する場所がはっきりし、学習の進行を見える化しやすくなります。それぞれのリポジトリがはっきりとした目的を持つことで、それぞれの役割が明確になり、管理もしやすくなるでしょう。

また、新しいリポジトリを作成することで、これまでの学習内容やコード、読書ノートなどが混ざることなく、それぞれ独立して管理できるというメリットもあります。これにより、後から見返した時にも探しやすくなります。

それぞれの学習内容や成果物を整理し、見やすくすることで、自分自身の学習の進行を把握しやすくなるだけでなく、他の人が見た時にも理解しやすい形になると思います。それぞれのリポジトリで何が行われているのかを明確にすることは、自身の学習を深め、他人との共有にも役立つでしょう。

## RFC3339形式

### RFC339形式って何

おそらく、"RFC 3339"の形式について尋ねているのかと思います。RFC 3339は、日付と時刻の表現方法に関するインターネット標準です。

具体的には、RFC 3339では日付と時刻を以下の形式で表現します:

```text
YYYY-MM-DDTHH:MM:SSZ
```

ここで、

YYYYは4桁の年を、
MMは2桁の月を、
DDは2桁の日を、
Tは日付と時刻の区切りを、
HHは2桁の時を、
MMは2桁の分を、
SSは2桁の秒を、
Zは協定世界時(UTC)を示しています。
例えば、"2023-05-10T13:30:00Z"という表現は、協定世界時で2023年5月10日の13時30分を表しています。

## その他

### 真善美ってなに

真善美（しんぜんび）は、西洋哲学において古代ギリシャ時代から続く、哲学的価値観の三原則です。これらの概念は、真理（真）、道徳（善）、美（美）を表しています。

真（しん、真理） - 真理は、事物や現象の本質や実在を理解し、知識を追求することを意味します。哲学や科学の目的は、真理を追求し、正確な理解や記述を提供することです。

善（ぜん、道徳） - 善は、倫理的な行動や道徳的価値を指します。善を追求することは、正しい行いや他者に対する配慮、正義や平和の実現に努めることを意味します。哲学的倫理学は、善の概念や行動原理を研究する分野です。

美（び、美） - 美は、美しさや魅力、芸術的価値を表します。美を追求することは、美しいものや感動を与える経験を通じて、人間の精神や感情を豊かにすることを意味します。美学は、美の概念や審美判断を研究する分野です。

真善美は、人間の理性や感性を満たす重要な価値観であり、哲学や人間の生活において重要な役割を果たしています。これらの価値観は、様々な分野において理解や実践が求められる普遍的なものです。

### 自分が何が得意かわからない。何があっても上位互換がいる。強みを活かせと言われても強みがないと思う

自分の強みを見つけるのは、しばしば困難なことです。自分の特性や能力について客観的に評価するのは難しいからです。しかし、それは決して不可能なことではありません。以下にいくつかの方法を挙げてみます：

フィードバックの収集：周りの人々に自分の強みや改善点について聞くことで、自分が見落としている可能性のある強みを見つけることができます。これは上司、同僚、友人、家族など、あなたと関わりのある人々に対して行うことができます。

自己反省：自分が何に時間を費やしているか、何を楽しんでいるか、何に成功しているかを考えることで、自分の強みを見つける手がかりを得ることができます。

強みを見つけるためのツール：ストレングスファインダーなどの自己評価ツールは、あなたの強みを特定し、それらをどのように活用できるかについての洞察を提供してくれます。

試行錯誤：新しいスキルや趣味を試すことで、自分が何に興味があり、何が得意なのかを見つけることができます。

コーチングやカウンセリング：専門的な視点から自分を見つめ直すことで、自分の強みやパターンを見つけるのに役立つことがあります。

それぞれが上位互換を持つという視点も確かに存在しますが、それは強みがないということを意味するわけではありません。それぞれの人が持つ経験、視点、スキルは独自のもので、それぞれが独自の価値を提供できます。あなたが提供できる独自の価値を見つけ、それを活用することが重要です。
