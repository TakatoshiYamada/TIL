# 12th May 2023

## ピタゴラスの定理

## injection

### injectioのドキュメントとサンプル

<https://docs.ruby-lang.org/ja/latest/method/Enumerable/i/inject.html>

```ruby
# 1から10までの和を求める
(1..10).inject(0) {|result, i| result + i } #=> 55
```

```ruby
# 1から10までの積を求める
(1..10).inject(1) {|result, i| result * i } #=> 3628800
```

```ruby
# 1から10までの最大値を求める
(1..10).inject {|result, i| result > i ? result : i } #=> 10
```

```ruby
# 1から10までの最小値を求める
(1..10).inject {|result, i| result < i ? result : i } #=> 1
```

```ruby
# 1から10までの偶数の和を求める
(1..10).inject(0) {|result, i| i % 2 == 0 ? result + i : result } #=> 30
```

```ruby
# 1から10までの奇数の和を求める
(1..10).inject(0) {|result, i| i % 2 == 1 ? result + i : result } #=> 25
```

```ruby
# 1から10までの偶数の積を求める
(1..10).inject(1) {|result, i| i % 2 == 0 ? result * i : result } #=> 3840
```

```ruby
# 1から10までの奇数の積を求める
(1..10).inject(1) {|result, i| i % 2 == 1 ? result * i : result } #=> 945
```

```ruby
# 1から10までの偶数の最大値を求める
(1..10).inject {|result, i| i % 2 == 0 && result < i ? i : result } #=> 10
```

```ruby
# 1から10までの奇数の最大値を求める
(1..10).inject {|result, i| i % 2 == 1 && result < i ? i : result } #=> 9
```

```ruby
# 1から10までの偶数の最小値を求める
(1..10).inject {|result, i| i % 2 == 0 && result > i ? i : result } #=> 2
```

```ruby
# 1から10までの奇数の最小値を求める
(1..10).inject {|result, i| i % 2 == 1 && result > i ? i : result } #=> 1
```

```ruby
# 1から10までの偶数の和と積を求める
(1..10).inject([0, 1]) {|result, i| i % 2 == 0 ? [result[0] + i, result[1] * i] : result } #=> [30, 3840]
```

```ruby
# 1から10までの奇数の和と積を求める
(1..10).inject([0, 1]) {|result, i| i % 2 == 1 ? [result[0] + i, result[1] * i] : result } #=> [25, 945]
```

```ruby
# 1から10までの偶数の最大値と最小値を求める
(1..10).inject([0, 11]) {|result, i| i % 2 == 0 ? [result[0] > i ? result[0] : i, result[1] < i ? result[1] : i] : result } #=> [10, 2]
```

```ruby
# 1から10までの奇数の最大値と最小値を求める
(1..10).inject([0, 11]) {|result, i| i % 2 == 1 ? [result[0] > i ? result[0] : i, result[1] < i ? result[1] : i] : result } #=> [9, 1]
```

```ruby
# 1から10までの偶数の和と積と最大値と最小値を求める
(1..10).inject([0, 1, 0, 11]) {|result, i| i % 2 == 0 ? [result[0] + i, result[1] * i, result[2] > i ? result[2] : i, result[3] < i ? result[3] : i] : result } #=> [30, 3840, 10, 2]
```

```ruby
# 1から10までの奇数の和と積と最大値と最小値を求める
(1..10).inject([0, 1, 0, 11]) {|result, i| i % 2 == 1 ? [result[0] + i, result[1] * i, result[2] > i ? result[2] : i, result[3] < i ? result[3] : i] : result } #=> [25, 945, 9, 1]
```

### 畳み込みについて教えて

"畳み込み"という用語は、主にプログラミングや数学の分野で使われ、一連の値を単一の値に"畳み込む"という概念を表現します。

プログラミングの文脈では、畳み込みはリスト、配列、コレクションなどの要素を組み合わせる操作を指します。この操作は、初期値を取り、コレクションの各要素に対して二項演算（加算、乗算、文字列結合など）を適用し、最終的な結果を生成します。

たとえば、Rubyでは inject メソッドを用いて畳み込み操作を行います。以下の例では、配列のすべての要素を合計しています。

```ruby
[1, 2, 3, 4, 5].inject(0) { |sum, num| sum + num } # => 15
```

この例では、畳み込み操作は 0（初期値）から始まり、配列の各要素に対してブロック内の操作（この場合は加算）を行い、最終的な合計値を返します。

数学の文脈では、畳み込みは主に信号処理において使用され、2つの関数fとgの畳み込みは新たな関数を生成します。この新たな関数は、fとgがどの程度重なるかを測定します。

以上のように、畳み込みは一連の値を単一の値に統合する一般的な概念を表す言葉です。その具体的な意味は、文脈によります。

### injectってmapやeachと何が違うの

map、each、injectは、Rubyで提供されるEnumerableモジュールのメソッドで、それぞれ異なる目的と動作を持っています。

each: これはRubyの基本的なイテレーション（反復）メソッドで、配列やハッシュなどの各要素に対して指定したブロックを実行します。eachは元のコレクションを変更せず、通常は何らかの副作用（例えば、出力の表示や外部の変数の更新）のために使用されます。

```ruby
[1, 2, 3].each { |n| puts n }
# Output:
# 1
# 2
# 3
```

map: eachと同様に、mapもコレクションの各要素に対してブロックを実行します。しかし、mapはブロックの結果を新しい配列に収集します。元のコレクションは変更されません。

```ruby
new_array = [1, 2, 3].map { |n| n * n }
# new_array is now [1, 4, 9]
```

inject: inject（または reduce）は、コレクションのすべての要素を一つの値に結合するために使用されます。injectは初期値（省略可能）と結合のための二項演算を引数として取ります。

```ruby
sum = [1, 2, 3].inject(0) { |result, n| result + n }
# sum is now 6
```

上記のコードでは、injectメソッドが配列のすべての要素を加算しています。resultは累積的な結果（初期値は0）を保持し、nは現在の要素です。ブロック内の結果（この場合はresult + n）が次のイテレーションのresultの値になります。

要するに、これらのメソッドはすべてイテレーションを提供しますが、その使用目的と結果は異なります。

## DB関連

### DBを学ぶモチベーションが上がらない

データベースを学ぶことは、一見すると大変かつ地味な作業に感じられるかもしれません。しかし、その重要性や価値を理解することで、モチベーションを高めることが可能です。以下にいくつかの観点を挙げてみます。

現代の世界はデータ駆動: 私たちが日常で利用するほとんどのサービスやアプリケーション（SNS、オンラインショッピング、モバイルゲームなど）は、すべてデータベース上に情報を保存し、それを利用しています。データベースを理解することは、これらのサービスがどのように動作しているかを理解する第一歩です。

需要と雇用の機会: データベース管理や操作のスキルは、IT業界では非常に需要が高く、多くの雇用機会があります。スキルを磨くことで、キャリアの幅を広げることができます。

あらゆる問題解決に役立つ: データベースを理解することは、ビジネス問題を解決するための重要なスキルです。たとえば、顧客データを分析して売上を増加させる戦略を立てたり、在庫管理を最適化したりするためには、データベースの知識が必要です。

自身のプロジェクトに役立つ: 自分自身でウェブサイトやアプリを作成する際にも、データベースは欠かせません。ユーザーの情報を保存したり、ユーザーにパーソナライズされた体験を提供するためには、データベースが必要です。

これらを考えると、データベースを学ぶことは時間と労力をかける価値があると言えます。また、一歩ずつ学び進めることで、自分自身の成長を感じることもモチベーションに繋がるでしょう。

### メチャクチャ大事じゃん

はい、データベースは確かに非常に重要です。現代の情報社会では、データベースは情報を保存、整理、検索、分析するための基盤となっています。データベースを扱えるスキルを持っていることは、あなたのキャリアやプロジェクトに大きな利点をもたらします。

また、データベースを学ぶことで、データの構造や関係性を理解する力が養われ、他の技術領域への応用も可能となります。例えば、機械学習やデータ分析の分野でも、データベースの知識は大変役立ちます。

データベースを学ぶことは、あなたの技術力を向上させ、より多くの機会を引き寄せることができるでしょう。少しずつ学んでいくことで、その価値を実感していただけると思います。

### ER図ってなに

ER図（エンティティ-リレーションシップ図）は、データベースの構造を視覚化するための図表です。データベース設計やシステム設計の初期段階で使用されることが多く、データベースの各部分がどのように関連しているかを示します。

ER図には主に次の3つのコンポーネントが含まれます：

エンティティ: これは実世界のオブジェクトや概念を表し、データベースで表現されるものです。たとえば、'顧客'、'注文'、'商品'などがエンティティになります。ER図では、エンティティは長方形で表現されます。

属性: これはエンティティが持つ特性を表します。たとえば、'顧客'エンティティの属性は'名前'、'住所'、'メールアドレス'などになります。ER図では、属性はエンティティに接続された楕円で表現されます。

リレーションシップ: これは2つ以上のエンティティ間の関係を表します。たとえば、'顧客'エンティティと'注文'エンティティの間にはリレーションシップが存在します。ER図では、リレーションシップはダイヤモンド形状で表現され、関連するエンティティに線で接続されます。

これらの要素を組み合わせて、データベースの複雑な構造を視覚化し、理解しやすくすることができます。

### ER図ってどうやって書くの

ER図（エンティティ-リレーションシップ図）を作成する際は、以下の基本的な手順に従うことが一般的です：

エンティティの識別：最初に、モデル化したい現実世界のオブジェクトや概念を特定します。これらはエンティティとなります。例えば、データベースが顧客管理システムであれば、「顧客」、「注文」、「商品」などがエンティティになる可能性があります。

属性の識別：次に、各エンティティが持つ特性を特定します。これらは属性となります。例えば、「顧客」エンティティの場合、属性は「名前」、「住所」、「メールアドレス」などになります。

リレーションシップの識別：2つ以上のエンティティ間の関係を特定します。これらはリレーションシップとなります。例えば、「顧客」エンティティと「注文」エンティティの間には「顧客は注文を行う」というリレーションシップがあります。

ER図の描画：エンティティ、属性、リレーションシップをER図に描きます。エンティティは長方形で、属性は楕円で、リレーションシップはダイヤモンド形で表現されます。これらの形状は線で接続されて表示されます。

カーディナリティの表現：エンティティ間のリレーションシップにおけるカーディナリティ（一対一、一対多、多対多などの関係）を表示します。これは通常、リレーションシップを示す線の端に記号をつけることで表現されます。

レビューと改善：最後に、作成したER図をレビューし、必要に応じて改善します。これには、ビジネス要件を満たしているか、論理的なエラーや不足がないか、利害関係者が理解しやすいかなどを確認します。

これらの作業を手動で行うこともできますが、ER図を作成するための専用のソフトウェアツール（例：Lucidchart, draw.io, Visioなど）を使用することで、効率的に作業を進めることができます。
